<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Bobik Shooter</title>
    <style>
        :root { --hud-bg: rgba(0,0,0,0.6); --accent: #ffb300; --danger: #ff4444; --success: #44ff44; }
        body { margin:0; overflow:hidden; background:#0b0e11; color:#fff; font-family: "Segoe UI", sans-serif; user-select:none; }
        
        #crosshair { position:absolute; top:50%; left:50%; width:16px; height:16px; transform:translate(-50%,-50%); pointer-events:none; z-index:5; transition: transform 0.1s; }
        #crosshair:before, #crosshair:after { content:""; position:absolute; background:#0f0; box-shadow: 0 0 4px #0f0; }
        #crosshair:before { width:2px; height:14px; left:7px; top:1px; }
        #crosshair:after { width:14px; height:2px; top:7px; left:1px; }
        #crosshair.hit { transform: translate(-50%, -50%) scale(2); background: red; }

        #hud-top { position:absolute; top:20px; left:20px; display:flex; gap:16px; z-index:6; align-items:flex-start; pointer-events: none; }
        .card { background:var(--hud-bg); padding:10px 14px; border-radius:12px; border:1px solid rgba(255,255,255,0.1); box-shadow:0 8px 20px rgba(0,0,0,0.5); backdrop-filter: blur(5px); pointer-events: auto; }
        
        #profile { display:flex; align-items:center; gap:12px; }
        #profile img { width:42px; height:42px; border-radius:50%; border:2px solid var(--accent); background: #333; }
        #stats { font-weight:700; color:#ddd; font-size: 0.9rem; }
        #score-display { color: var(--success); font-weight: 800; font-size: 1.1rem; text-shadow: 0 0 10px rgba(68,255,68,0.4); }

        #timer { position:absolute; top:20px; left:50%; transform:translateX(-50%); padding:8px 20px; background:var(--hud-bg); border:1px solid rgba(255,255,255,0.1); border-radius:12px; font-weight:800; letter-spacing:2px; font-size: 1.5rem; z-index: 6; }

        #health-bar-container { position: absolute; bottom: 30px; left: 30px; width: 250px; height: 16px; background: rgba(0,0,0,0.8); border: 1px solid #555; border-radius: 8px; z-index: 6; overflow: hidden; }
        #health-fill { width: 100%; height: 100%; background: var(--success); transition: width 0.2s, background 0.2s; }
        #health-text { position: absolute; top: -25px; left: 0; font-weight: 900; letter-spacing: 1px; text-shadow: 1px 1px 2px black; }

        #weapon-bar { position:absolute; bottom:30px; left:50%; transform:translateX(-50%); display:flex; gap:10px; z-index:6; }
        .slot { padding:10px 16px; border-radius:10px; border:1px solid rgba(255,255,255,0.1); background:rgba(0,0,0,0.6); min-width:80px; text-align:center; color:#888; transition: all 0.1s; }
        .slot.active { border-color:var(--accent); color:#fff; transform: translateY(-5px); box-shadow:0 0 15px rgba(255,179,0,0.3); }

        #ammo { position:absolute; bottom:30px; right:30px; text-align:right; z-index: 6; }
        #ammo-count { font-size:48px; font-weight:900; line-height: 1; }
        #ammo-reserve { font-size: 24px; color: #aaa; font-weight: 700; }
        #weapon-name { color:var(--accent); font-weight:800; letter-spacing:2px; text-transform: uppercase; margin-top: 5px; }

        #reload-msg { position:absolute; top:60%; left:50%; transform:translateX(-50%); color:var(--danger); font-weight:900; font-size: 1.2rem; display:none; z-index:7; text-shadow: 0 2px 4px black; }

        #scoreboard { position:absolute; top:100px; right:20px; background:var(--hud-bg); border:1px solid rgba(255,255,255,0.08); border-radius:12px; padding:15px; min-width:200px; z-index:6; }
        #scoreboard h4 { margin:0 0 10px; font-size:12px; letter-spacing:2px; color:#aaa; border-bottom: 1px solid #444; padding-bottom: 5px; }
        #score-list { list-style:none; padding:0; margin:0; display:flex; flex-direction:column; gap:8px; }
        #score-list li { display:flex; justify-content:space-between; font-weight:700; font-size: 0.9rem; }

        #names-layer { position:absolute; inset:0; pointer-events:none; z-index:5; font-weight:800; text-shadow:0 1px 3px #000; }

        .overlay { position:absolute; inset:0; background:rgba(0,0,0,0.85); display:none; align-items:center; justify-content:center; flex-direction:column; gap:20px; color:#fff; z-index:20; backdrop-filter: blur(5px); cursor: pointer; }
        .overlay h1 { margin:0; font-size: 3rem; text-transform: uppercase; font-style: italic; text-shadow: 0 0 20px var(--accent); }
        .btn { padding:12px 24px; border-radius:8px; border:none; background:var(--accent); color: black; font-weight:800; cursor:pointer; font-size: 1rem; text-decoration: none; transition: transform 0.1s; }
        .btn:hover { transform: scale(1.05); box-shadow: 0 0 15px var(--accent); }

        #shop-menu { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; padding: 20px; border-radius: 16px; border: 2px solid #444; z-index: 30; width: 400px; box-shadow: 0 20px 50px rgba(0,0,0,0.8); }
        #shop-menu h2 { margin-top: 0; color: var(--accent); border-bottom: 1px solid #444; padding-bottom: 10px; display: flex; justify-content: space-between; }
        .shop-item { display: flex; justify-content: space-between; align-items: center; padding: 12px; background: #222; margin-bottom: 8px; border-radius: 8px; border: 1px solid #333; transition: background 0.2s; }
        .shop-item:hover { background: #333; }
        .buy-btn { background: #444; color: white; border: none; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-weight: bold; }
        .buy-btn:hover { background: var(--success); color: black; }

        .spinner { width: 40px; height: 40px; border: 4px solid rgba(255,255,255,0.1); border-top-color: var(--accent); border-radius: 50%; animation: spin 1s infinite linear; }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div id="crosshair"></div>
    <div id="hud-top">
        <div id="profile" class="card">
            <img id="avatar" alt="avatar">
            <div>
                <div id="nickname">Loading...</div>
                <div id="stats">K/D 0/0</div>
                <div id="score-display">$800</div>
            </div>
        </div>
        <div style="color: #aaa; font-weight: bold; font-size: 0.8rem; align-self: center;">[B] SHOP</div>
    </div>
    <div id="timer">Waiting...</div>
    <div id="scoreboard" class="card"><h4>LEADERBOARD</h4><ul id="score-list"></ul></div>
    <div id="health-bar-container"><div id="health-text">HP 100</div><div id="health-fill"></div></div>
    <div id="weapon-bar">
        <div id="slot-1" class="slot"><span>1</span> Knife</div>
        <div id="slot-2" class="slot active"><span>2</span> Glock</div>
        <div id="slot-3" class="slot"><span>3</span> AK-47</div>
        <div id="slot-4" class="slot" style="display:none;"><span>4</span> AWP</div>
    </div>
    <div id="ammo">
        <span id="ammo-count">20</span><span style="font-size:24px;color:#888;">/</span><span id="ammo-reserve">120</span>
        <div id="weapon-name">Glock</div>
    </div>
    <div id="reload-msg">RELOADING...</div>
    <div id="names-layer"></div>

    <div id="waiting-overlay" class="overlay" style="display: flex;">
        <div class="spinner"></div>
        <h2>WAITING FOR PLAYERS</h2>
        <div style="font-size: 0.9rem; color: #aaa;">Waiting for at least 2 players...</div>
    </div>
    <div id="game-over-overlay" class="overlay">
        <h1 id="winner-text">VICTORY</h1>
        <div id="end-stats"></div>
        <a href="/" class="btn">Return to Lobby</a>
    </div>

    <div id="shop-menu">
        <h2>WEAPON SHOP <span id="shop-balance">$0</span></h2>
        <div class="shop-item">
            <div><div style="font-weight:bold;">Refill Ammo</div><div style="font-size:0.8rem; color:#888;">Max out current clip & reserve</div></div>
            <button class="buy-btn" onclick="buy('ammo', 200)">$200</button>
        </div>
        <div class="shop-item">
            <div><div style="font-weight:bold;">AWP Sniper</div><div style="font-size:0.8rem; color:#888;">One shot, one kill.</div></div>
            <button class="buy-btn" onclick="buy('awp', 2500)">$2500</button>
        </div>
        <div style="margin-top:10px; font-size:0.8rem; text-align:center; color:#666;">Press [B] or [ESC] to close</div>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/" } }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        const qs = (id) => document.getElementById(id);
        const url = new URL(window.location.href);
        const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
        const nickParam = url.searchParams.get('nick') || 'Player';
        const userId = url.searchParams.get('userID') || '';
        
        const avatarUrl = `https://api.dicebear.com/7.x/avataaars/svg?seed=${encodeURIComponent(nickParam)}&backgroundColor=ffdfbf`;
        qs('nickname').textContent = nickParam;
        qs('avatar').src = avatarUrl;

        let myId = null;
        let myScore = 0;
        let roundActive = false;
        const remotePlayers = new Map(); 

        const weaponStats = {
            knife: { name: "Knife", type: "melee", slot: 1, damage: 50, delay: 500, clip: 0, reserve: 0 },
            pistol: { name: "Glock", type: "gun", slot: 2, damage: 20, delay: 200, clip: 20, reserve: 120 },
            ak47:   { name: "AK-47", type: "auto", slot: 3, damage: 30, delay: 100, clip: 30, reserve: 90 },
            awp:    { name: "AWP", type: "sniper", slot: 4, damage: 100, delay: 1500, clip: 5, reserve: 20 }
        };

        const gameState = {
            activeSlot: 2,
            inventory: { 1: 'knife', 2: 'pistol', 3: 'ak47' }, 
            ammo: { clip: 20, reserve: 120 },
            canShoot: true,
            isReloading: false,
            health: 100
        };

        const socket = new WebSocket(`${protocol}://${window.location.host}/ws/bobik?nick=${encodeURIComponent(nickParam)}&userID=${encodeURIComponent(userId)}`);
        
        socket.onmessage = (ev) => {
            const msg = JSON.parse(ev.data);
            if (msg.type === 'welcome') {
                myId = msg.id;
                roundActive = msg.roundActive;
                updateGameFlow(msg);
            }
            if (msg.type === 'state') {
                roundActive = msg.roundActive;
                updatePlayers(msg.players || []);
                updateTimer(msg.timeLeft, msg.playerCount);
                // Hide waiting if round is active
                if (roundActive) qs('waiting-overlay').style.display = 'none';
            }
            if (msg.type === 'game_over') showGameOver(msg);
            if (msg.type === 'buy_ack' && msg.success) {
                if (msg.item === 'ammo') {
                    const s = weaponStats[gameState.inventory[gameState.activeSlot]];
                    gameState.ammo.clip = s.clip; gameState.ammo.reserve = s.reserve;
                    updateHUD();
                } else if (msg.item === 'awp') {
                    gameState.inventory[4] = 'awp';
                    qs('slot-4').style.display = 'block';
                    equip(4);
                }
            }
        };

        window.buy = (item, cost) => {
            if (myScore >= cost) socket.send(JSON.stringify({ type: 'buy', item: item }));
        };

        function send(msg) { if (socket.readyState === WebSocket.OPEN) socket.send(JSON.stringify(msg)); }

        // --- THREE.JS ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x8fbde0); // Sky color
        scene.fog = new THREE.Fog(0x8fbde0, 20, 300);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const controls = new PointerLockControls(camera, document.body);
        camera.position.y = 12;
        scene.add(controls.getObject());

        // Lighting
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const sun = new THREE.DirectionalLight(0xffffff, 0.8);
        sun.position.set(100, 200, 100);
        sun.castShadow = true;
        scene.add(sun);

        // Floor
        const floorMat = new THREE.MeshStandardMaterial({ color: 0xc4b28a, roughness: 0.9 });
        const floor = new THREE.Mesh(new THREE.PlaneGeometry(500, 500), floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Map Colliders (Manual Layout)
        const colliders = [];
        function addBox(x, z, w, d, h, color) {
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), new THREE.MeshStandardMaterial({ color: color }));
            mesh.position.set(x, h / 2, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
            colliders.push(new THREE.Box3().setFromObject(mesh));
        }
        // Classic Map Layout
        addBox(0, -60, 120, 40, 20, 0x8B4513); // Back wall
        addBox(-80, 40, 40, 220, 30, 0x666666); // Left wall
        addBox(80, 40, 40, 220, 30, 0x666666); // Right wall
        addBox(0, 100, 80, 40, 15, 0x8B4513); // Front block
        addBox(-30, 0, 30, 30, 12, 0x556b2f); // Mid cover
        addBox(30, 30, 30, 30, 12, 0x556b2f); // Mid cover 2

        // Weapon Models (Simplified Geometries)
        const weaponGroup = new THREE.Group();
        camera.add(weaponGroup);
        const recoilGroup = new THREE.Group();
        weaponGroup.add(recoilGroup);

        function makeGunModel(color, length) {
            const g = new THREE.Group();
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, length), new THREE.MeshStandardMaterial({ color }));
            body.position.z = -length/2;
            g.add(body);
            g.position.set(1.5, -1.5, -1);
            return g;
        }
        const models = {
            knife: makeGunModel(0xaaaaaa, 1.5),
            pistol: makeGunModel(0x333333, 2),
            ak47: makeGunModel(0x8B4513, 3.5),
            awp: makeGunModel(0x224422, 5)
        };
        // Add scope to AWP
        const scope = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 0.8), new THREE.MeshStandardMaterial({color:0x000000}));
        scope.rotation.x = Math.PI/2; scope.position.set(0, 0.4, -1.5);
        models.awp.children[0].add(scope);

        function equip(slot) {
            if (gameState.isReloading) return;
            const key = gameState.inventory[slot];
            if (!key) return;
            gameState.activeSlot = slot;
            recoilGroup.clear();
            recoilGroup.add(models[key]);
            
            // Reset FOV
            camera.fov = 75; camera.updateProjectionMatrix();

            const s = weaponStats[key];
            if (s.type !== 'melee') {
                gameState.ammo.clip = s.clip; 
                gameState.ammo.reserve = s.reserve; 
            }
            updateHUD();
        }

        function updateHUD() {
            const key = gameState.inventory[gameState.activeSlot];
            const s = weaponStats[key];
            qs('weapon-name').textContent = s.name;
            if (s.type === 'melee') { qs('ammo-count').textContent = "--"; qs('ammo-reserve').textContent = "--"; }
            else { qs('ammo-count').textContent = gameState.ammo.clip; qs('ammo-reserve').textContent = gameState.ammo.reserve; }
            const hpPct = Math.max(0, gameState.health) + "%";
            qs('health-fill').style.width = hpPct;
            qs('health-text').textContent = "HP " + gameState.health;
            document.querySelectorAll('.slot').forEach(el => el.classList.remove('active'));
            qs(`slot-${gameState.activeSlot}`).classList.add('active');
            qs('shop-balance').textContent = "$" + myScore;
        }

        function shoot() {
            if (gameState.isReloading || !gameState.canShoot) return;
            const key = gameState.inventory[gameState.activeSlot];
            const s = weaponStats[key];

            if (s.type !== 'melee') {
                if (gameState.ammo.clip <= 0) { reload(); return; }
                gameState.ammo.clip--;
                updateHUD();
            }

            gameState.canShoot = false;
            recoilGroup.position.z = 0.2; recoilGroup.rotation.x = 0.1;
            setTimeout(() => { recoilGroup.position.z = 0; recoilGroup.rotation.x = 0; }, 100);

            // AWP Zoom visual
            if (s.type === 'sniper') {
                camera.fov = (camera.fov === 75) ? 75 : 20; // Keep zoom if active
                camera.updateProjectionMatrix();
            }

            const ray = new THREE.Raycaster();
            ray.setFromCamera(new THREE.Vector2(0,0), camera);
            const targets = Array.from(remotePlayers.values()).map(e => e.mesh);
            const hits = ray.intersectObjects(targets, true); // true for recursive (mesh group)
            
            if (hits.length > 0 && hits[0].distance < 300) {
                // Find the root object with userData.id
                let obj = hits[0].object;
                while (obj.parent && !obj.userData.id) obj = obj.parent;
                
                if (obj.userData.id) {
                    send({ type: "hit", target: obj.userData.id, damage: s.damage });
                    // Hit Marker
                    const ch = qs('crosshair');
                    ch.classList.add('hit');
                    setTimeout(() => ch.classList.remove('hit'), 100);
                }
            }
            setTimeout(() => gameState.canShoot = true, s.delay);
        }

        function reload() {
            const key = gameState.inventory[gameState.activeSlot];
            const s = weaponStats[key];
            if (s.type === 'melee' || gameState.isReloading) return;
            gameState.isReloading = true;
            qs('reload-msg').style.display = 'block';
            recoilGroup.rotation.x = -0.5;
            setTimeout(() => {
                gameState.isReloading = false;
                qs('reload-msg').style.display = 'none';
                recoilGroup.rotation.x = 0;
                gameState.ammo.clip = s.clip;
                updateHUD();
            }, 1500);
        }

        // --- INPUT ---
        // Lock pointer on any click if not in shop/overlays
        document.addEventListener('click', (e) => {
            if (qs('shop-menu').style.display === 'block') return;
            if (!controls.isLocked) controls.lock();
            else shoot();
        });

        // Toggle Shop
        function toggleShop() {
            const menu = qs('shop-menu');
            if (menu.style.display === 'block') {
                menu.style.display = 'none';
                controls.lock();
            } else {
                menu.style.display = 'block';
                controls.unlock();
            }
        }

        document.addEventListener('keydown', (e) => {
            if (qs('shop-menu').style.display === 'block' && e.code !== 'KeyB' && e.code !== 'Escape') return;
            switch(e.code) {
                case 'KeyB': toggleShop(); break;
                case 'KeyR': reload(); break;
                case 'Digit1': equip(1); break;
                case 'Digit2': equip(2); break;
                case 'Digit3': equip(3); break;
                case 'Digit4': equip(4); break;
                case 'KeyW': moveFwd = true; break;
                case 'KeyS': moveBwd = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyD': moveRight = true; break;
                case 'Space': if (velocity.y === 0) velocity.y = 80; break;
            }
        });
        
        document.addEventListener('mousedown', (e) => {
            if (e.button === 2 && gameState.inventory[gameState.activeSlot] === 'awp') {
                camera.fov = (camera.fov === 75) ? 20 : 75;
                camera.updateProjectionMatrix();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.code==='KeyW') moveFwd=false; if (e.code==='KeyS') moveBwd=false;
            if (e.code==='KeyA') moveLeft=false; if (e.code==='KeyD') moveRight=false;
        });

        // Movement
        const velocity = new THREE.Vector3();
        let moveFwd=false, moveBwd=false, moveLeft=false, moveRight=false;
        let prevTime = performance.now();

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const delta = (time - prevTime) / 1000;
            prevTime = time;

            if (controls.isLocked) {
                // Physics
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= 200.0 * delta; 
                const direction = new THREE.Vector3();
                direction.z = Number(moveFwd) - Number(moveBwd);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();
                if (moveFwd || moveBwd) velocity.z -= direction.z * 400.0 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
                controls.getObject().position.y += velocity.y * delta;

                // Simple collision floor
                if (controls.getObject().position.y < 6) { velocity.y = 0; controls.getObject().position.y = 6; }
                
                // Simple wall collision (push back)
                const pos = controls.getObject().position;
                colliders.forEach(box => {
                    if (box.containsPoint(pos)) {
                        controls.moveForward(velocity.z * delta * 2); // bounce
                    }
                });

                if (myId) send({ type: 'update', pos: controls.getObject().position, rotY: controls.getObject().rotation.y });
            }
            renderer.render(scene, camera);
            updateNameTags();
        }
        animate();

        function updatePlayers(list) {
            const seen = new Set();
            list.forEach(p => {
                seen.add(p.id);
                if (p.id === myId) {
                    qs('nickname').textContent = p.name;
                    qs('stats').textContent = `K/D ${p.kills}/${p.deaths}`;
                    qs('score-display').textContent = "$" + p.score;
                    myScore = p.score;
                    gameState.health = p.health;
                    updateHUD();
                    return;
                }
                let entry = remotePlayers.get(p.id);
                if (!entry) {
                    const mesh = new THREE.Group();
                    mesh.userData.id = p.id; // Crucial for raycast
                    
                    const body = new THREE.Mesh(new THREE.CapsuleGeometry(1.5, 4, 4, 8), new THREE.MeshStandardMaterial({ color: 0xff0000 }));
                    mesh.add(body);
                    const head = new THREE.Mesh(new THREE.SphereGeometry(1.5), new THREE.MeshStandardMaterial({ color: 0xffccaa }));
                    head.position.y = 3;
                    mesh.add(head);

                    const div = document.createElement('div');
                    div.style.position = 'absolute'; div.style.color = 'white'; div.style.fontWeight = 'bold'; div.style.textShadow = '0 0 4px black';
                    div.textContent = p.name;
                    qs('names-layer').appendChild(div);
                    entry = { mesh, div };
                    remotePlayers.set(p.id, entry);
                    scene.add(mesh);
                }
                entry.mesh.position.set(p.pos.x, p.pos.y - 2, p.pos.z);
                entry.mesh.rotation.y = p.rotY;
                entry.div.textContent = `${p.name} [${p.health}]`;
            });
            for (const [id, entry] of remotePlayers) { if (!seen.has(id)) { scene.remove(entry.mesh); entry.div.remove(); remotePlayers.delete(id); } }
            
            const ul = qs('score-list'); ul.innerHTML = '';
            list.sort((a,b) => b.kills - a.kills).forEach(p => {
                const li = document.createElement('li');
                li.innerHTML = `<span>${p.name}</span> <span>${p.kills}/${p.deaths}</span>`;
                ul.appendChild(li);
            });
        }

        function updateNameTags() {
            remotePlayers.forEach(entry => {
                const head = entry.mesh.position.clone().add(new THREE.Vector3(0, 5, 0));
                head.project(camera);
                const x = (head.x * .5 + .5) * window.innerWidth;
                const y = (-(head.y * .5) + .5) * window.innerHeight;
                if (head.z < 1) { entry.div.style.display = 'block'; entry.div.style.transform = `translate(-50%, -50%) translate(${x}px, ${y}px)`; }
                else entry.div.style.display = 'none';
            });
        }

        function updateGameFlow(msg) { qs('waiting-overlay').style.display = msg.roundActive ? 'none' : 'flex'; }
        function updateTimer(s, c) { 
            const m = Math.floor(s/60), sec = (s%60).toString().padStart(2,'0'); 
            qs('timer').textContent = `${m}:${sec}`; 
            if (!roundActive && c < 2) qs('waiting-overlay').style.display = 'flex';
        }
        function showGameOver(msg) {
            controls.unlock();
            qs('game-over-overlay').style.display = 'flex';
            qs('winner-text').textContent = (msg.winnerId === myId) ? "VICTORY!" : "DEFEAT";
            qs('winner-text').style.color = (msg.winnerId === myId) ? "#4f4" : "#f44";
            qs('end-stats').innerHTML = msg.scoreboard.map(p => `<div>${p.name}: ${p.kills} K</div>`).join('');
        }

        equip(2);
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
    </script>
</body>
</html>