<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Bobik Shooter</title>
    <style>
        :root {
            --hud-bg: rgba(0, 0, 0, 0.6);
            --accent: #ffb300;
            --danger: #ff4444;
            --success: #44ff44;
        }

        body {
            margin: 0;
            overflow: hidden;
            background: #0b0e11;
            color: #fff;
            font-family: "Segoe UI", sans-serif;
            user-select: none;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 16px;
            height: 16px;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 5;
            transition: transform 0.1s;
        }

        #crosshair:before,
        #crosshair:after {
            content: "";
            position: absolute;
            background: #0f0;
            box-shadow: 0 0 4px #0f0;
        }

        #crosshair:before {
            width: 2px;
            height: 14px;
            left: 7px;
            top: 1px;
        }

        #crosshair:after {
            width: 14px;
            height: 2px;
            top: 7px;
            left: 1px;
        }

        #crosshair.hit {
            transform: translate(-50%, -50%) scale(2);
            background: red;
        }

        #hud-top {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            gap: 16px;
            z-index: 6;
            align-items: flex-start;
            pointer-events: none;
        }

        .card {
            background: var(--hud-bg);
            padding: 10px 14px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            pointer-events: auto;
        }

        #profile {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        #profile img {
            width: 42px;
            height: 42px;
            border-radius: 50%;
            border: 2px solid var(--accent);
            background: #333;
        }

        #stats {
            font-weight: 700;
            color: #ddd;
            font-size: 0.9rem;
        }

        #score-display {
            color: var(--success);
            font-weight: 800;
            font-size: 1.1rem;
            text-shadow: 0 0 10px rgba(68, 255, 68, 0.4);
        }

        #timer {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 20px;
            background: var(--hud-bg);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            font-weight: 800;
            letter-spacing: 2px;
            font-size: 1.5rem;
            z-index: 6;
        }

        #health-bar-container {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 250px;
            height: 16px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #555;
            border-radius: 8px;
            z-index: 6;
            overflow: hidden;
        }

        #health-fill {
            width: 100%;
            height: 100%;
            background: var(--success);
            transition: width 0.2s, background 0.2s;
        }

        #health-text {
            position: absolute;
            top: -25px;
            left: 0;
            font-weight: 900;
            letter-spacing: 1px;
            text-shadow: 1px 1px 2px black;
        }

        #weapon-bar {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 6;
        }

        .slot {
            padding: 10px 16px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(0, 0, 0, 0.6);
            min-width: 80px;
            text-align: center;
            color: #888;
            transition: all 0.1s;
        }

        .slot.active {
            border-color: var(--accent);
            color: #fff;
            transform: translateY(-5px);
            box-shadow: 0 0 15px rgba(255, 179, 0, 0.3);
        }

        #ammo {
            position: absolute;
            bottom: 30px;
            right: 30px;
            text-align: right;
            z-index: 6;
        }

        #ammo-count {
            font-size: 48px;
            font-weight: 900;
            line-height: 1;
        }

        #ammo-reserve {
            font-size: 24px;
            color: #aaa;
            font-weight: 700;
        }

        #weapon-name {
            color: var(--accent);
            font-weight: 800;
            letter-spacing: 2px;
            text-transform: uppercase;
            margin-top: 5px;
        }

        #reload-msg {
            position: absolute;
            top: 60%;
            left: 50%;
            transform: translateX(-50%);
            color: var(--danger);
            font-weight: 900;
            font-size: 1.2rem;
            display: none;
            z-index: 7;
            text-shadow: 0 2px 4px black;
        }

        #scoreboard {
            position: absolute;
            top: 100px;
            right: 20px;
            background: var(--hud-bg);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 15px;
            min-width: 200px;
            z-index: 6;
        }

        #scoreboard h4 {
            margin: 0 0 10px;
            font-size: 12px;
            letter-spacing: 2px;
            color: #aaa;
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
        }

        #score-list {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        #score-list li {
            display: flex;
            justify-content: space-between;
            font-weight: 700;
            font-size: 0.9rem;
        }

        #names-layer {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 5;
            font-weight: 800;
            text-shadow: 0 1px 3px #000;
        }

        .overlay {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            gap: 20px;
            color: #fff;
            z-index: 20;
            backdrop-filter: blur(5px);
            cursor: pointer;
        }

        /* Practice overlay should not blur the game */
        .practice-overlay {
            background: transparent !important;
            backdrop-filter: none !important;
        }

        .overlay h1 {
            margin: 0;
            font-size: 3rem;
            text-transform: uppercase;
            font-style: italic;
            text-shadow: 0 0 20px var(--accent);
        }

        .btn {
            padding: 12px 24px;
            border-radius: 8px;
            border: none;
            background: var(--accent);
            color: black;
            font-weight: 800;
            cursor: pointer;
            font-size: 1rem;
            text-decoration: none;
            transition: transform 0.1s;
        }

        .btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px var(--accent);
        }

        #shop-menu {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #1a1a1a;
            padding: 20px;
            border-radius: 16px;
            border: 2px solid #444;
            z-index: 30;
            width: 400px;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.8);
        }

        #shop-menu h2 {
            margin-top: 0;
            color: var(--accent);
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
            display: flex;
            justify-content: space-between;
        }

        .shop-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background: #222;
            margin-bottom: 8px;
            border-radius: 8px;
            border: 1px solid #333;
            transition: background 0.2s;
        }

        .shop-item:hover {
            background: #333;
        }

        .buy-btn {
            background: #444;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
        }

        .buy-btn:hover {
            background: var(--success);
            color: black;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s infinite linear;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body>
    <div id="crosshair"></div>
    <div id="hud-top">
        <div id="profile" class="card">
            <img id="avatar" alt="avatar">
            <div>
                <div id="nickname">Loading...</div>
                <div id="stats">K/D 0/0</div>
                <div id="score-display">$800</div>
            </div>
        </div>
        <div style="color: #aaa; font-weight: bold; font-size: 0.8rem; align-self: center;">[B] SHOP</div>
    </div>
    <div id="timer">Waiting...</div>
    <div id="scoreboard" class="card">
        <h4>LEADERBOARD</h4>
        <ul id="score-list"></ul>
    </div>
    <div id="health-bar-container">
        <div id="health-text">HP 100</div>
        <div id="health-fill"></div>
    </div>
    <div id="weapon-bar">
        <div id="slot-1" class="slot"><span>1</span> Knife</div>
        <div id="slot-2" class="slot active"><span>2</span> Glock</div>
        <div id="slot-3" class="slot"><span>3</span> AK-47</div>
        <div id="slot-4" class="slot" style="display:none;"><span>4</span> AWP</div>
    </div>
    <div id="ammo">
        <span id="ammo-count">20</span><span style="font-size:24px;color:#888;">/</span><span
            id="ammo-reserve">120</span>
        <div id="weapon-name">Glock</div>
    </div>
    <div id="reload-msg">RELOADING...</div>
    <div id="names-layer"></div>

    <div id="waiting-overlay" class="overlay practice-overlay" style="display: flex; pointer-events: none;">
        <h2 style="position:absolute; top:30px; color: var(--accent);">ðŸŽ¯ PRACTICE MODE</h2>
        <div style="font-size: 0.9rem; color: #aaa; position:absolute; top:70px;">Waiting for players... Move and shoot
            to warm up!</div>
        <div style="font-size: 0.8rem; color: #666; position:absolute; top:100px;">Infinite ammo â€¢ Click to practice
        </div>
    </div>
    <div id="game-over-overlay" class="overlay">
        <h1 id="winner-text">VICTORY</h1>
        <div id="end-stats"></div>
        <a href="/" class="btn">Return to Lobby</a>
    </div>

    <div id="shop-menu">
        <h2>ðŸ”« WEAPON SHOP <span id="shop-balance">$0</span></h2>
        <div style="max-height: 400px; overflow-y: auto;">
            <div
                style="font-size:0.8rem; color:#888; margin-bottom:10px; padding-bottom:8px; border-bottom:1px solid #333;">
                SECONDARY</div>
            <div class="shop-item">
                <div>
                    <div style="font-weight:bold;">Desert Eagle</div>
                    <div style="font-size:0.8rem; color:#888;">High damage pistol. 55 DMG</div>
                </div>
                <button class="buy-btn" onclick="buy('deagle', 700)">$700</button>
            </div>
            <div style="font-size:0.8rem; color:#888; margin:10px 0; padding-bottom:8px; border-bottom:1px solid #333;">
                PRIMARY</div>
            <div class="shop-item">
                <div>
                    <div style="font-weight:bold;">P90 SMG</div>
                    <div style="font-size:0.8rem; color:#888;">Fast fire rate, 50 rounds. 18 DMG</div>
                </div>
                <button class="buy-btn" onclick="buy('smg', 1200)">$1200</button>
            </div>
            <div class="shop-item">
                <div>
                    <div style="font-weight:bold;">XM1014 Shotgun</div>
                    <div style="font-size:0.8rem; color:#888;">Devastating close range. 90 DMG</div>
                </div>
                <button class="buy-btn" onclick="buy('shotgun', 1800)">$1800</button>
            </div>
            <div class="shop-item">
                <div>
                    <div style="font-weight:bold;">M4A4</div>
                    <div style="font-size:0.8rem; color:#888;">Accurate rifle. 33 DMG</div>
                </div>
                <button class="buy-btn" onclick="buy('m4a4', 3100)">$3100</button>
            </div>
            <div class="shop-item">
                <div>
                    <div style="font-weight:bold;">AWP Sniper</div>
                    <div style="font-size:0.8rem; color:#888;">One shot, one kill. 115 DMG</div>
                </div>
                <button class="buy-btn" onclick="buy('awp', 4750)">$4750</button>
            </div>
            <div style="font-size:0.8rem; color:#888; margin:10px 0; padding-bottom:8px; border-bottom:1px solid #333;">
                UTILITY</div>
            <div class="shop-item">
                <div>
                    <div style="font-weight:bold;">Refill Ammo</div>
                    <div style="font-size:0.8rem; color:#888;">Max out current clip & reserve</div>
                </div>
                <button class="buy-btn" onclick="buy('ammo', 200)">$200</button>
            </div>
        </div>
        <div style="margin-top:10px; font-size:0.8rem; text-align:center; color:#666;">Press [B] to close</div>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/" } }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        const qs = (id) => document.getElementById(id);
        const url = new URL(window.location.href);
        const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
        const nickParam = url.searchParams.get('nick') || 'Player';
        const userId = url.searchParams.get('userID') || '';

        const avatarUrl = `https://api.dicebear.com/7.x/avataaars/svg?seed=${encodeURIComponent(nickParam)}&backgroundColor=ffdfbf`;
        qs('nickname').textContent = nickParam;
        qs('avatar').src = avatarUrl;

        let myId = null;
        let myScore = 0;

        const remotePlayers = new Map();
        const dummyObjects = new Map(); // visual meshes

        const weaponStats = {
            knife: { name: "Knife", type: "melee", slot: 1, damage: 50, delay: 500, clip: 0, reserve: 0 },
            pistol: { name: "Glock", type: "gun", slot: 2, damage: 22, delay: 200, clip: 20, reserve: 120 },
            deagle: { name: "Desert Eagle", type: "gun", slot: 2, damage: 55, delay: 400, clip: 7, reserve: 35 },
            smg: { name: "P90", type: "auto", slot: 3, damage: 18, delay: 66, clip: 50, reserve: 100 },
            shotgun: { name: "XM1014", type: "shotgun", slot: 3, damage: 90, delay: 700, clip: 7, reserve: 32 },
            ak47: { name: "AK-47", type: "auto", slot: 3, damage: 36, delay: 100, clip: 30, reserve: 90 },
            m4a4: { name: "M4A4", type: "auto", slot: 3, damage: 33, delay: 90, clip: 30, reserve: 90 },
            awp: { name: "AWP", type: "sniper", slot: 4, damage: 115, delay: 1500, clip: 5, reserve: 20 }
        };

        const gameState = {
            activeSlot: 2,
            inventory: { 1: 'knife', 2: 'pistol', 3: 'ak47' },
            ammo: { clip: 20, reserve: 120 },
            canShoot: true,
            isReloading: false,
            health: 100,
            practiceMode: true, // Enable shooting during wait
            dummies: [] // Practice targets
        };

        const socket = new WebSocket(`${protocol}://${window.location.host}/ws/bobik?nick=${encodeURIComponent(nickParam)}&userID=${encodeURIComponent(userId)}`);

        socket.onmessage = (ev) => {
            const msg = JSON.parse(ev.data);
            if (msg.type === 'welcome') {
                myId = msg.id;
                roundActive = msg.roundActive;
                if (msg.dummies) {
                    gameState.dummies = msg.dummies;
                    updateDummies();
                }
                updateGameFlow(msg);
            }
            if (msg.type === 'dummies_update') {
                gameState.dummies = msg.dummies;
                updateDummies();
            }
            if (msg.type === 'buy_ack') {
                if (msg.success && msg.newScore !== undefined) {
                    myScore = msg.newScore;
                    updateHUD();
                }
            }
            if (msg.type === 'state') {
                roundActive = msg.roundActive;
                updatePlayers(msg.players || []);
                updateTimer(msg.timeLeft, msg.playerCount);
                // Hide waiting if round is active
                if (roundActive) qs('waiting-overlay').style.display = 'none';
            }
            if (msg.type === 'game_over') showGameOver(msg);
            if (msg.type === 'buy_ack' && msg.success) {
                if (msg.item === 'ammo') {
                    const s = weaponStats[gameState.inventory[gameState.activeSlot]];
                    gameState.ammo.clip = s.clip; gameState.ammo.reserve = s.reserve;
                    updateHUD();
                } else if (msg.item === 'awp') {
                    gameState.inventory[4] = 'awp';
                    qs('slot-4').style.display = 'block';
                    equip(4);
                }
            }
        };

        window.buy = (item, cost) => {
            if (myScore >= cost) socket.send(JSON.stringify({ type: 'buy', item: item }));
        };

        function send(msg) { if (socket.readyState === WebSocket.OPEN) socket.send(JSON.stringify(msg)); }

        // --- THREE.JS ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x8fbde0); // Sky color
        scene.fog = new THREE.Fog(0x8fbde0, 20, 300);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const controls = new PointerLockControls(camera, document.body);
        camera.position.y = 12;
        scene.add(controls.getObject());

        // Lighting
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const sun = new THREE.DirectionalLight(0xffffff, 0.8);
        sun.position.set(100, 200, 100);
        sun.castShadow = true;
        scene.add(sun);

        // Floor
        const floorMat = new THREE.MeshStandardMaterial({ color: 0xc4b28a, roughness: 0.9 });
        const floor = new THREE.Mesh(new THREE.PlaneGeometry(500, 500), floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Dummy management
        function updateDummies() {
            if (!gameState.dummies) return;

            // Rebuild dummies
            dummyObjects.forEach(d => scene.remove(d));
            dummyObjects.clear();

            gameState.dummies.forEach((pos, idx) => {
                const geo = new THREE.CylinderGeometry(3, 3, 14, 16);
                const mat = new THREE.MeshStandardMaterial({ color: 0xffaa00 });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(pos.x, pos.y, pos.z);
                mesh.userData = { index: idx };
                mesh.castShadow = true;
                scene.add(mesh);
                dummyObjects.set(idx, mesh);
            });
        }

        // Map Colliders (Manual Layout)
        const colliders = [];
        function addBox(x, z, w, d, h, color) {
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), new THREE.MeshStandardMaterial({ color: color }));
            mesh.position.set(x, h / 2, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
            colliders.push(new THREE.Box3().setFromObject(mesh));
        }
        // Classic Map Layout
        addBox(0, -60, 120, 40, 20, 0x8B4513); // Back wall
        addBox(-80, 40, 40, 220, 30, 0x666666); // Left wall
        addBox(80, 40, 40, 220, 30, 0x666666); // Right wall
        addBox(0, 100, 80, 40, 15, 0x8B4513); // Front block
        addBox(-30, 0, 30, 30, 12, 0x556b2f); // Mid cover
        addBox(30, 30, 30, 30, 12, 0x556b2f); // Mid cover 2

        // Weapon Models - Improved gun shapes
        const weaponGroup = new THREE.Group();
        camera.add(weaponGroup);
        const recoilGroup = new THREE.Group();
        weaponGroup.add(recoilGroup);

        function makeGunModel(config) {
            const g = new THREE.Group();
            const { color, barrelLen, barrelRad, bodyLen, bodyH, bodyW, hasStock, hasMag, hasScope } = config;
            const metallic = new THREE.MeshStandardMaterial({ color: color || 0x222222, metalness: 0.7, roughness: 0.3 });
            const dark = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.5, roughness: 0.7 });

            // Barrel
            const bR = barrelRad || 0.08;
            const barrel = new THREE.Mesh(new THREE.CylinderGeometry(bR, bR, barrelLen || 1.5, 12), metallic);
            barrel.rotation.x = Math.PI / 2;
            barrel.position.z = -(barrelLen || 1.5) / 2;
            g.add(barrel);

            // Muzzle flash handling point (tip)
            const tip = new THREE.Group();
            tip.position.z = -(barrelLen || 1.5) - 0.1;
            g.add(tip);

            // Main Body
            const body = new THREE.Mesh(new THREE.BoxGeometry(bodyW || 0.25, bodyH || 0.35, bodyLen || 0.8), metallic);
            body.position.set(0, -(bodyH || 0.35) / 2 + 0.1, 0.2);
            g.add(body);

            // Grip
            const grip = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.4, 0.2), dark);
            grip.position.set(0, -0.45, 0.3);
            grip.rotation.x = 0.2;
            g.add(grip);

            // Trigger Guard
            const guard = new THREE.Mesh(new THREE.TorusGeometry(0.1, 0.02, 4, 12), dark);
            guard.position.set(0, -0.25, 0.25);
            g.add(guard);

            // Stock
            if (hasStock) {
                const stock = new THREE.Mesh(new THREE.BoxGeometry(0.14, 0.2, 0.6), dark);
                stock.position.set(0, -0.15, 0.7);
                g.add(stock);
                // Buttplate
                const plate = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.25, 0.05), dark);
                plate.position.set(0, -0.15, 1.0);
                g.add(plate);
            }

            // Magazine
            if (hasMag) {
                const mag = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.4, 0.15), dark);
                mag.position.set(0, -0.6, 0.1);
                mag.rotation.x = 0.1;
                g.add(mag);
            }

            // Scope / Sights
            if (hasScope) {
                const scope = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.12, 0.6, 12), dark);
                scope.rotation.x = Math.PI / 2;
                scope.position.set(0, 0.22, 0.1);
                g.add(scope);
            } else {
                // Iron sights
                const frontSight = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.08, 0.04), dark);
                frontSight.position.set(0, bR + 0.04, -(barrelLen || 1.5));
                g.add(frontSight);
                const rearSight = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.06, 0.04), dark);
                rearSight.position.set(0, 0.2, 0.5);
                g.add(rearSight);
            }

            g.position.set(1.2, -1.2, -1.5);

            // Bobbing animation helper
            g.userData.origPos = g.position.clone();
            return g;
        }

        // Simple knife model
        function makeKnifeModel() {
            const g = new THREE.Group();
            const blade = new THREE.Mesh(
                new THREE.BoxGeometry(0.05, 0.15, 1.2),
                new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.9, roughness: 0.2 })
            );
            blade.position.z = -0.6;
            g.add(blade);
            const handle = new THREE.Mesh(
                new THREE.BoxGeometry(0.12, 0.2, 0.3),
                new THREE.MeshStandardMaterial({ color: 0x3d2817, roughness: 0.8 })
            );
            handle.position.set(0, -0.05, 0.15);
            g.add(handle);
            g.position.set(1.2, -1.2, -1.2);
            return g;
        }

        const models = {
            knife: makeKnifeModel(),
            pistol: makeGunModel({ color: 0x2a2a2a, barrelLen: 0.6, bodyLen: 0.5, bodyH: 0.25, bodyW: 0.18, hasMag: true }),
            deagle: makeGunModel({ color: 0x8b8b8b, barrelLen: 0.8, barrelRad: 0.1, bodyLen: 0.6, bodyH: 0.35, bodyW: 0.22, hasMag: true }),
            smg: makeGunModel({ color: 0x1a1a1a, barrelLen: 1.0, bodyLen: 0.7, bodyH: 0.3, bodyW: 0.2, hasMag: true }),
            shotgun: makeGunModel({ color: 0x2d2d2d, barrelLen: 1.8, barrelRad: 0.12, bodyLen: 0.6, bodyH: 0.3, bodyW: 0.25, hasStock: true }),
            ak47: makeGunModel({ color: 0x8B4513, barrelLen: 1.5, bodyLen: 0.8, bodyH: 0.3, bodyW: 0.22, hasStock: true, hasMag: true }),
            m4a4: makeGunModel({ color: 0x2d2d2d, barrelLen: 1.4, bodyLen: 0.85, bodyH: 0.28, bodyW: 0.2, hasStock: true, hasMag: true }),
            awp: makeGunModel({ color: 0x224422, barrelLen: 2.2, barrelRad: 0.1, bodyLen: 1.0, bodyH: 0.35, bodyW: 0.25, hasStock: true, hasMag: true, hasScope: true })
        };

        function equip(slot) {
            if (gameState.isReloading) return;
            const key = gameState.inventory[slot];
            if (!key) return;
            gameState.activeSlot = slot;
            recoilGroup.clear();
            recoilGroup.add(models[key]);

            // Reset FOV
            camera.fov = 75; camera.updateProjectionMatrix();

            const s = weaponStats[key];
            if (s.type !== 'melee') {
                gameState.ammo.clip = s.clip;
                gameState.ammo.reserve = s.reserve;
            }
            updateHUD();
        }

        function updateHUD() {
            const key = gameState.inventory[gameState.activeSlot];
            const s = weaponStats[key];
            qs('weapon-name').textContent = s.name;
            if (s.type === 'melee') { qs('ammo-count').textContent = "--"; qs('ammo-reserve').textContent = "--"; }
            else { qs('ammo-count').textContent = gameState.ammo.clip; qs('ammo-reserve').textContent = gameState.ammo.reserve; }
            const hpPct = Math.max(0, gameState.health) + "%";
            qs('health-fill').style.width = hpPct;
            qs('health-text').textContent = "HP " + gameState.health;
            document.querySelectorAll('.slot').forEach(el => el.classList.remove('active'));
            qs(`slot-${gameState.activeSlot}`).classList.add('active');
            qs('shop-balance').textContent = "$" + myScore;
        }

        function shoot() {
            if (gameState.isReloading || !gameState.canShoot) return;
            const key = gameState.inventory[gameState.activeSlot];
            const s = weaponStats[key];

            if (s.type !== 'melee') {
                if (gameState.ammo.clip <= 0) { reload(); return; }
                gameState.ammo.clip--;
                updateHUD();
            }

            gameState.canShoot = false;
            recoilGroup.position.z = 0.2; recoilGroup.rotation.x = 0.1;
            setTimeout(() => { recoilGroup.position.z = 0; recoilGroup.rotation.x = 0; }, 100);

            // AWP Zoom visual
            if (s.type === 'sniper') {
                camera.fov = (camera.fov === 75) ? 75 : 20; // Keep zoom if active
                camera.updateProjectionMatrix();
            }

            const ray = new THREE.Raycaster();
            ray.setFromCamera(new THREE.Vector2(0, 0), camera);

            // Check dummies
            if (dummyObjects.size > 0) {
                const dHits = ray.intersectObjects(Array.from(dummyObjects.values()), false);
                if (dHits.length > 0 && dHits[0].distance < 300) {
                    const dObj = dHits[0].object;
                    const dIdx = dObj.userData.index;

                    // Visual feedback
                    dObj.material.color.setHex(0xff0000);
                    setTimeout(() => dObj.material.color.setHex(0xffaa00), 100);

                    // Show hit marker
                    const marker = document.createElement('div');
                    marker.className = 'damage-number';
                    marker.style.left = window.innerWidth / 2 + 'px';
                    marker.style.top = window.innerHeight / 2 - 50 + 'px';
                    marker.textContent = "10";
                    document.body.appendChild(marker);
                    setTimeout(() => marker.remove(), 800);

                    if (socket.readyState === WebSocket.OPEN) {
                        socket.send(JSON.stringify({ type: 'hit_dummy', index: dIdx }));
                    }
                    // Stop ray here (hit dummy blocking shot)
                    setTimeout(() => gameState.canShoot = true, s.delay);
                    return;
                }
            }

            const targets = Array.from(remotePlayers.values()).map(e => e.mesh);
            const hits = ray.intersectObjects(targets, true); // true for recursive (mesh group)

            if (hits.length > 0 && hits[0].distance < 300) {
                // Find the root object with userData.id
                let obj = hits[0].object;
                while (obj.parent && !obj.userData.id) obj = obj.parent;

                if (obj.userData.id) {
                    send({ type: "hit", target: obj.userData.id, damage: s.damage });
                    // Hit Marker
                    const ch = qs('crosshair');
                    ch.classList.add('hit');
                    setTimeout(() => ch.classList.remove('hit'), 100);
                }
            }
            setTimeout(() => gameState.canShoot = true, s.delay);
        }

        function reload() {
            const key = gameState.inventory[gameState.activeSlot];
            const s = weaponStats[key];
            if (s.type === 'melee' || gameState.isReloading) return;
            gameState.isReloading = true;
            qs('reload-msg').style.display = 'block';
            recoilGroup.rotation.x = -0.5;
            setTimeout(() => {
                gameState.isReloading = false;
                qs('reload-msg').style.display = 'none';
                recoilGroup.rotation.x = 0;
                gameState.ammo.clip = s.clip;
                updateHUD();
            }, 1500);
        }

        // --- INPUT ---
        // Lock pointer on any click if not in shop/overlays
        document.addEventListener('click', (e) => {
            if (qs('shop-menu').style.display === 'block') return;
            if (!controls.isLocked) controls.lock();
            else shoot();
        });

        // Toggle Shop
        function toggleShop() {
            const menu = qs('shop-menu');
            if (menu.style.display === 'block') {
                menu.style.display = 'none';
                controls.lock();
            } else {
                menu.style.display = 'block';
                controls.unlock();
            }
        }

        // Buy weapons/items from shop
        function buy(item, cost) {
            if (myScore < cost) {
                // Show insufficient funds feedback
                const shopBalance = qs('shop-balance');
                shopBalance.style.color = '#ff4444';
                setTimeout(() => shopBalance.style.color = '', 500);
                return;
            }

            // Send buy request
            if (socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({ type: 'buy', item: item }));
            }

            myScore -= cost;
            updateHUD();

            // Handle different purchases
            switch (item) {
                case 'ammo':
                    const key = gameState.inventory[gameState.activeSlot];
                    if (key && weaponStats[key]) {
                        gameState.ammo.clip = weaponStats[key].clip;
                        gameState.ammo.reserve = weaponStats[key].reserve;
                        updateHUD();
                    }
                    break;
                case 'deagle':
                    gameState.inventory[2] = 'deagle'; // Replace pistol slot
                    updateSlotDisplay(2, 'D.Eagle');
                    equip(2);
                    break;
                case 'smg':
                    gameState.inventory[3] = 'smg';
                    updateSlotDisplay(3, 'P90');
                    equip(3);
                    break;
                case 'shotgun':
                    gameState.inventory[3] = 'shotgun';
                    updateSlotDisplay(3, 'XM1014');
                    equip(3);
                    break;
                case 'm4a4':
                    gameState.inventory[3] = 'm4a4';
                    updateSlotDisplay(3, 'M4A4');
                    equip(3);
                    break;
                case 'awp':
                    gameState.inventory[4] = 'awp';
                    qs('slot-4').style.display = 'block';
                    updateSlotDisplay(4, 'AWP');
                    equip(4);
                    break;
            }

            toggleShop(); // Close shop after purchase
        }

        function updateSlotDisplay(slot, name) {
            const slotEl = qs(`slot-${slot}`);
            if (slotEl) {
                slotEl.innerHTML = `<span>${slot}</span> ${name}`;
            }
        }

        // Expose functions to global scope for onclick handlers
        window.buy = buy;
        window.toggleShop = toggleShop;

        document.addEventListener('keydown', (e) => {
            if (qs('shop-menu').style.display === 'block' && e.code !== 'KeyB' && e.code !== 'Escape') return;
            switch (e.code) {
                case 'KeyB': toggleShop(); break;
                case 'KeyR': reload(); break;
                case 'Digit1': equip(1); break;
                case 'Digit2': equip(2); break;
                case 'Digit3': equip(3); break;
                case 'Digit4': equip(4); break;
                case 'KeyW': moveFwd = true; break;
                case 'KeyS': moveBwd = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyD': moveRight = true; break;
                case 'Space': if (velocity.y === 0) velocity.y = 80; break;
            }
        });

        document.addEventListener('mousedown', (e) => {
            if (e.button === 2 && gameState.inventory[gameState.activeSlot] === 'awp') {
                camera.fov = (camera.fov === 75) ? 20 : 75;
                camera.updateProjectionMatrix();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.code === 'KeyW') moveFwd = false; if (e.code === 'KeyS') moveBwd = false;
            if (e.code === 'KeyA') moveLeft = false; if (e.code === 'KeyD') moveRight = false;
        });

        // Movement
        const velocity = new THREE.Vector3();
        let moveFwd = false, moveBwd = false, moveLeft = false, moveRight = false;
        let prevTime = performance.now();

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const delta = (time - prevTime) / 1000;
            prevTime = time;

            if (controls.isLocked) {
                // Physics
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= 200.0 * delta;
                const direction = new THREE.Vector3();
                direction.z = Number(moveFwd) - Number(moveBwd);
                direction.x = Number(moveRight) - Number(moveLeft);
                // Hit dummies (practice)
                const dHits = ray.intersectObjects(Array.from(dummyObjects.values()), false);
                if (dHits.length > 0 && dHits[0].distance < 300) {
                    const dObj = dHits[0].object;
                    const dIdx = dObj.userData.index;
                    // Visual feedback
                    dObj.material.color.setHex(0xff0000);
                    setTimeout(() => dObj.material.color.setHex(0xffaa00), 100);

                    // Show hit marker
                    const marker = document.createElement('div');
                    marker.className = 'damage-number';
                    marker.style.left = window.innerWidth / 2 + 'px';
                    marker.style.top = window.innerHeight / 2 - 50 + 'px';
                    marker.textContent = "10";
                    document.body.appendChild(marker);
                    setTimeout(() => marker.remove(), 800);

                    socket.send(JSON.stringify({ type: 'hit_dummy', index: dIdx }));
                }
                if (moveFwd || moveBwd) velocity.z -= direction.z * 400.0 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
                controls.getObject().position.y += velocity.y * delta;

                // Simple collision floor
                if (controls.getObject().position.y < 6) { velocity.y = 0; controls.getObject().position.y = 6; }

                // Simple wall collision (push back)
                const pos = controls.getObject().position;
                colliders.forEach(box => {
                    if (box.containsPoint(pos)) {
                        controls.moveForward(velocity.z * delta * 2); // bounce
                    }
                });

                if (myId) send({ type: 'update', pos: controls.getObject().position, rotY: controls.getObject().rotation.y });
            }
            renderer.render(scene, camera);
            updateNameTags();
        }
        animate();

        function updatePlayers(list) {
            const seen = new Set();
            list.forEach(p => {
                seen.add(p.id);
                if (p.id === myId) {
                    qs('nickname').textContent = p.name;
                    qs('stats').textContent = `K/D ${p.kills}/${p.deaths}`;
                    qs('score-display').textContent = "$" + p.score;
                    myScore = p.score;
                    gameState.health = p.health;
                    updateHUD();
                    return;
                }
                let entry = remotePlayers.get(p.id);
                if (!entry) {
                    const mesh = new THREE.Group();
                    mesh.userData.id = p.id; // Crucial for raycast

                    const body = new THREE.Mesh(new THREE.CapsuleGeometry(1.5, 4, 4, 8), new THREE.MeshStandardMaterial({ color: 0xff0000 }));
                    mesh.add(body);
                    const head = new THREE.Mesh(new THREE.SphereGeometry(1.5), new THREE.MeshStandardMaterial({ color: 0xffccaa }));
                    head.position.y = 3;
                    mesh.add(head);

                    const div = document.createElement('div');
                    div.style.position = 'absolute'; div.style.color = 'white'; div.style.fontWeight = 'bold'; div.style.textShadow = '0 0 4px black';
                    div.textContent = p.name;
                    qs('names-layer').appendChild(div);
                    entry = { mesh, div };
                    remotePlayers.set(p.id, entry);
                    scene.add(mesh);
                }
                entry.mesh.position.set(p.pos.x, p.pos.y - 2, p.pos.z);
                entry.mesh.rotation.y = p.rotY;
                entry.div.textContent = `${p.name} [${p.health}]`;
            });
            for (const [id, entry] of remotePlayers) { if (!seen.has(id)) { scene.remove(entry.mesh); entry.div.remove(); remotePlayers.delete(id); } }

            const ul = qs('score-list'); ul.innerHTML = '';
            list.sort((a, b) => b.kills - a.kills).forEach(p => {
                const li = document.createElement('li');
                li.innerHTML = `<span>${p.name}</span> <span>${p.kills}/${p.deaths}</span>`;
                ul.appendChild(li);
            });
        }

        function updateNameTags() {
            remotePlayers.forEach(entry => {
                const head = entry.mesh.position.clone().add(new THREE.Vector3(0, 5, 0));
                head.project(camera);
                const x = (head.x * .5 + .5) * window.innerWidth;
                const y = (-(head.y * .5) + .5) * window.innerHeight;
                if (head.z < 1) { entry.div.style.display = 'block'; entry.div.style.transform = `translate(-50%, -50%) translate(${x}px, ${y}px)`; }
                else entry.div.style.display = 'none';
            });
        }

        function updateGameFlow(msg) { qs('waiting-overlay').style.display = msg.roundActive ? 'none' : 'flex'; }
        function updateTimer(s, c) {
            const m = Math.floor(s / 60), sec = (s % 60).toString().padStart(2, '0');
            qs('timer').textContent = `${m}:${sec}`;
            if (!roundActive && c < 2) qs('waiting-overlay').style.display = 'flex';
        }
        function showGameOver(msg) {
            controls.unlock();
            qs('game-over-overlay').style.display = 'flex';
            qs('winner-text').textContent = (msg.winnerId === myId) ? "VICTORY!" : "DEFEAT";
            qs('winner-text').style.color = (msg.winnerId === myId) ? "#4f4" : "#f44";
            qs('end-stats').innerHTML = msg.scoreboard.map(p => `<div>${p.name}: ${p.kills} K</div>`).join('');
        }

        equip(2);
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
    </script>
</body>

</html>