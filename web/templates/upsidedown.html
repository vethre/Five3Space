<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Upside Down</title>
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <link rel="stylesheet" href="/static/css/upsidedown_shop.css">
    <style>
        :root {
            --blood-red: #8B0000;
            --void-black: #0a0000;
            --ash-gray: #2a2020;
            --eerie-glow: rgba(255, 50, 50, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', sans-serif;
            background: var(--void-black);
            color: #ddd;
            overflow: hidden;
            cursor: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #game-canvas {
            display: block;
        }

        /* Vignette effect */
        #vignette {
            position: fixed;
            inset: 0;
            pointer-events: none;
            background: radial-gradient(ellipse at center, transparent 30%, rgba(0, 0, 0, 0.8) 100%);
            z-index: 5;
        }

        /* Scanlines for eerie TV effect */
        #scanlines {
            position: fixed;
            inset: 0;
            pointer-events: none;
            background: repeating-linear-gradient(0deg,
                    transparent,
                    transparent 2px,
                    rgba(0, 0, 0, 0.1) 2px,
                    rgba(0, 0, 0, 0.1) 4px);
            z-index: 6;
            opacity: 0.5;
        }

        /* Floating particles */
        #particles {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 4;
        }

        .particle {
            position: absolute;
            width: 3px;
            height: 3px;
            background: rgba(100, 50, 50, 0.5);
            border-radius: 50%;
            animation: float 10s infinite ease-in-out;
        }

        @keyframes float {

            0%,
            100% {
                transform: translateY(0) rotate(0deg);
                opacity: 0.3;
            }

            50% {
                transform: translateY(-100px) rotate(180deg);
                opacity: 0.7;
            }
        }

        /* HUD */
        .hud {
            position: fixed;
            z-index: 10;
            pointer-events: none;
        }

        #hud-top-left {
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .stat-bar {
            width: 200px;
            height: 20px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #333;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .stat-bar-fill {
            height: 100%;
            transition: width 0.3s, background 0.3s;
        }

        .stat-bar-label {
            position: absolute;
            top: 50%;
            left: 10px;
            transform: translateY(-50%);
            font-size: 0.8rem;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
        }

        #health-fill {
            background: linear-gradient(90deg, #4a0000, #ff0000);
        }

        #sanity-fill {
            background: linear-gradient(90deg, #1a0030, #8000ff);
        }

        .sanity-low #sanity-fill {
            animation: pulse-bar 0.5s infinite;
        }

        @keyframes pulse-bar {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        #hud-top-right {
            top: 20px;
            right: 20px;
            text-align: right;
        }

        #timer {
            font-size: 2rem;
            font-weight: 900;
            color: var(--blood-red);
            text-shadow: 0 0 20px var(--eerie-glow);
            font-family: 'Courier New', monospace;
        }

        #score {
            font-size: 1.5rem;
            color: #aaa;
            margin-top: 10px;
        }

        #hud-bottom {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
        }

        #flare-indicator {
            display: none;
            padding: 10px 20px;
            background: linear-gradient(135deg, #ff6600, #ffaa00);
            border-radius: 20px;
            font-weight: bold;
            color: black;
            animation: flare-pulse 0.5s infinite alternate;
        }

        #flare-indicator.active {
            display: block;
        }

        @keyframes flare-pulse {
            from {
                box-shadow: 0 0 10px #ff6600;
            }

            to {
                box-shadow: 0 0 30px #ffaa00;
            }
        }

        /* Custom cursor */
        #cursor {
            position: fixed;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 100, 100, 0.8);
            border-radius: 50%;
            pointer-events: none;
            z-index: 100;
            transform: translate(-50%, -50%);
            transition: transform 0.1s;
        }

        /* Screen shake effect */
        .screen-shake {
            animation: shake 0.2s infinite;
        }

        @keyframes shake {

            0%,
            100% {
                transform: translateX(0);
            }

            25% {
                transform: translateX(-5px);
            }

            75% {
                transform: translateX(5px);
            }
        }

        /* Overlays */
        .overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            gap: 20px;
            z-index: 50;
        }

        .overlay.active {
            display: flex;
        }

        .overlay h1 {
            font-size: 4rem;
            color: var(--blood-red);
            text-transform: uppercase;
            text-shadow: 0 0 30px var(--eerie-glow);
            animation: flicker-text 2s infinite;
        }

        @keyframes flicker-text {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.8;
            }

            52% {
                opacity: 0.3;
            }

            54% {
                opacity: 0.9;
            }
        }

        .btn {
            padding: 15px 40px;
            border-radius: 30px;
            border: 2px solid var(--blood-red);
            background: transparent;
            color: white;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            text-decoration: none;
        }

        .btn:hover {
            background: var(--blood-red);
            box-shadow: 0 0 30px var(--eerie-glow);
        }

        #game-over-overlay .stats {
            display: flex;
            gap: 30px;
            margin: 20px 0;
        }

        .stat-card {
            text-align: center;
            padding: 20px;
            background: rgba(139, 0, 0, 0.2);
            border: 1px solid #400;
            border-radius: 12px;
        }

        .stat-card .value {
            font-size: 2rem;
            font-weight: 900;
            color: white;
        }

        .stat-card .label {
            color: #888;
            text-transform: uppercase;
            font-size: 0.8rem;
        }

        /* Intro screen - starts visible with .active, hidden when removed */
        #intro-overlay.active {
            display: flex;
        }

        #intro-overlay h1 {
            font-family: 'Courier New', monospace;
            letter-spacing: 5px;
        }

        .instructions {
            max-width: 500px;
            text-align: center;
            color: #888;
            margin: 10px 0 20px;
        }

        /* Low sanity visual effects */
        .insane #vignette {
            background: radial-gradient(ellipse at center, transparent 10%, rgba(50, 0, 0, 0.9) 80%);
            animation: insane-vignette 0.5s infinite alternate;
        }

        @keyframes insane-vignette {
            from {
                opacity: 1;
            }

            to {
                opacity: 0.7;
            }
        }
    </style>
</head>

<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <div id="vignette"></div>
        <div id="scanlines"></div>
        <div id="particles"></div>
    </div>

    <div id="cursor"></div>

    <div class="hud" id="hud-top-left">
        <div class="stat-bar">
            <div class="stat-bar-fill" id="health-fill" style="width: 100%"></div>
            <span class="stat-bar-label">‚ù§Ô∏è HEALTH</span>
        </div>
        <div class="stat-bar" id="sanity-bar">
            <div class="stat-bar-fill" id="sanity-fill" style="width: 100%"></div>
            <span class="stat-bar-label">üß† SANITY</span>
        </div>
    </div>

    <div class="hud" id="hud-top-right">
        <div id="timer">3:00</div>
        <div id="score">SCORE: 0</div>
    </div>

    <div class="hud" id="hud-bottom">
        <div id="flare-indicator">üî• FLARE ACTIVE</div>
    </div>

    <div class="rogue-overlay" id="meta-lobby">
        <div class="rogue-panel">
            <div class="rogue-header">
                <div class="rogue-title">THE VOID</div>
                <div class="ember-display">
                    <div class="ember-icon"></div>
                    <span id="ember-count">---</span>
                </div>
            </div>

            <div class="rogue-tabs">
                <button class="rogue-tab-btn active" onclick="switchTab('upgrades')">Upgrades</button>
                <button class="rogue-tab-btn" onclick="switchTab('classes')">Classes</button>
                <button class="rogue-tab-btn" onclick="switchTab('modifiers')">Modifiers</button>
            </div>

            <div class="rogue-content active" id="tab-upgrades"></div>
            <div class="rogue-content" id="tab-classes"></div>
            <div class="rogue-content" id="tab-modifiers">
                <div style="width: 100%; margin-bottom: 20px; color: #aaa;">
                    <label style="display: flex; align-items: center; gap: 10px; font-size: 1.2rem; cursor: pointer;">
                        <input type="checkbox" id="endless-mode-check" style="width: 20px; height: 20px;">
                        ENDLESS NIGHTMARE MODE (Waves & Bosses)
                    </label>
                </div>
                <div id="mods-list"
                    style="display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 15px;">
                </div>
            </div>

            <button class="start-run-btn" onclick="initGame()">ENTER THE DARKNESS</button>
            <a href="/" class="back-home">EXIT TO LOBBY</a>
        </div>
    </div>

    <div class="overlay" id="game-over-overlay">
        <h1 id="game-over-title">CONSUMED</h1>
        <div class="stats">
            <div class="stat-card">
                <div class="value" id="final-time">0:00</div>
                <div class="label">Survived</div>
            </div>
            <div class="stat-card">
                <div class="value" id="final-score">0</div>
                <div class="label">Score</div>
            </div>
        </div>
        <button class="btn" onclick="restartGame()">TRY AGAIN</button>
        <a href="/" class="btn" style="border-color: #444;">‚Üê ESCAPE</a>
    </div>

    <script>
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const url = new URL(window.location.href);
        const userID = url.searchParams.get('userID') || '';
        const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';

        let socket;
        let myId = null;
        let gameState = null;
        let mouseX = 0, mouseY = 0;
        let keys = { w: false, a: false, s: false, d: false, shift: false };
        let playerPos = { x: 0, y: 0 };
        let gameStarted = false;
        let isSprinting = false;

        // Canvas setup
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);

        // Cursor
        document.addEventListener('mousemove', e => {
            mouseX = e.clientX;
            mouseY = e.clientY;
            document.getElementById('cursor').style.left = e.clientX + 'px';
            document.getElementById('cursor').style.top = e.clientY + 'px';
        });

        // Keyboard
        document.addEventListener('keydown', e => {
            const key = e.key.toLowerCase();
            if (key in keys) keys[key] = true;
            if (e.key === 'Shift') { keys.shift = true; isSprinting = true; }
            // F to use flare
            if (key === 'f' && gameStarted && socket?.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({ type: 'use_flare' }));
            }
        });
        document.addEventListener('keyup', e => {
            const key = e.key.toLowerCase();
            if (key in keys) keys[key] = false;
            if (e.key === 'Shift') { keys.shift = false; isSprinting = false; }
        });

        // Click to attack (shoot)
        canvas.addEventListener('mousedown', (e) => {
            if (!gameStarted || !socket || socket.readyState !== WebSocket.OPEN) return;

            // Left click: Shoot
            if (e.button === 0) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                // Calculate angle relative to center (player)
                const cx = canvas.width / 2;
                const cy = canvas.height / 2;
                const angle = Math.atan2(y - cy, x - cx);

                socket.send(JSON.stringify({ type: 'attack', angle: angle }));

                // Visual feedback (muzzle flash / tracer)
                ctx.save();
                ctx.translate(cx, cy);
                ctx.rotate(angle);
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(15, 0); // Start from player edge
                ctx.lineTo(300, 0); // Tracer length
                ctx.stroke();
                ctx.restore();

                // Sound effect (optional placeholder)
                // new Audio('/static/shoot.mp3').play().catch(()=>{});
            }
        });

        // F key for Flare
        document.addEventListener('keydown', e => {
            if (e.key.toLowerCase() === 'f' && gameStarted) {
                socket.send(JSON.stringify({ type: 'use_flare' }));
            }
        });

        // Create floating particles
        const particlesContainer = document.getElementById('particles');
        for (let i = 0; i < 50; i++) {
            const p = document.createElement('div');
            p.className = 'particle';
            p.style.left = Math.random() * 100 + '%';
            p.style.top = Math.random() * 100 + '%';
            p.style.animationDelay = Math.random() * 10 + 's';
            p.style.animationDuration = (8 + Math.random() * 5) + 's';
            particlesContainer.appendChild(p);
        }


        // ROGUELITE METADATA DEFINITIONS
        const UPGRADES = {
            "max_health": { name: "Hardened Body", desc: "+5% max health per level", baseCost: 50 },
            "max_sanity": { name: "Mental Fortitude", desc: "+5% max sanity per level", baseCost: 50 },
            "start_flares": { name: "Prepared", desc: "+1 starting flare per level", baseCost: 100 },
            "light_radius": { name: "Inner Light", desc: "+10% light radius per level", baseCost: 75 },
            "resource_spawn": { name: "Scavenger's Luck", desc: "+5% resource spawn rate per level", baseCost: 80 },
            "move_speed": { name: "Swift Feet", desc: "+3% movement speed per level", baseCost: 60 },
            "sanity_regen": { name: "Calm Mind", desc: "+10% sanity regen near light per level", baseCost: 70 },
            "damage_resist": { name: "Thick Skin", desc: "+5% damage resistance per level", baseCost: 90 },
        };

        const CLASSES = {
            "survivor": { name: "Survivor", desc: "Balanced stats. The default choice.", cost: 0 },
            "scout": { name: "Scout", desc: "+Speed, -Health. Fast and fragile.", cost: 200 },
            "psychic": { name: "Psychic", desc: "High Sanity Regen, but enemies sense you.", cost: 300 },
            "pyromancer": { name: "Pyromancer", desc: "Start with 3 Flares (Shorter duration).", cost: 250 },
        };

        const MODIFIERS = {
            "void_surge": { name: "Void Surge", desc: "+50% Enemies, +100% Embers.", mult: 2.0 },
            "dim_light": { name: "Dim Light", desc: "-50% Light Restore, +Resources.", mult: 1.3 },
            "quick_decay": { name: "Quick Decay", desc: "2x Sanity Drain.", mult: 1.5 },
            "hunter_moon": { name: "Hunter's Moon", desc: "+Enemy Sight, -Enemy Speed.", mult: 1.4 },
            "ghostly_mist": { name: "Ghostly Mist", desc: "Reduced Visibility.", mult: 1.6 },
            "blood_moon": { name: "Blood Moon", desc: "Hardcore. +200% Embers.", mult: 3.0 },
        };

        let playerMeta = null;
        let selectedMods = new Set();
        let selectedClass = "survivor";

        function switchTab(tabId) {
            document.querySelectorAll('.rogue-tab-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.rogue-content').forEach(c => c.classList.remove('active'));
            event.target.classList.add('active');
            document.getElementById('tab-' + tabId).classList.add('active');
        }

        async function fetchMeta() {
            try {
                const res = await fetch(`/upsidedown/shop?userID=${userID}`);
                playerMeta = await res.json();
                renderShop();
            } catch (e) {
                console.error("Failed to load meta", e);
            }
        }

        async function buyItem(action, id) {
            try {
                const res = await fetch(`/upsidedown/shop?userID=${userID}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action, id })
                });
                if (res.ok) {
                    playerMeta = await res.json();
                    renderShop();
                } else {
                    alert("Cannot purchase!");
                }
            } catch (e) { console.error(e); }
        }

        function selectClass(id) {
            selectedClass = id;
            renderShop();
        }

        function toggleMod(id) {
            if (selectedMods.has(id)) selectedMods.delete(id);
            else selectedMods.add(id);
            renderShop();
        }

        function renderShop() {
            if (!playerMeta) return;
            document.getElementById('ember-count').innerText = playerMeta.emberShards;

            // Upgrades
            const upContainer = document.getElementById('tab-upgrades');
            upContainer.innerHTML = '';
            for (const [id, def] of Object.entries(UPGRADES)) {
                const lvl = playerMeta.upgradeLevels[id] || 0;
                const cost = def.baseCost * (lvl + 1);
                const maxed = lvl >= 10;

                const div = document.createElement('div');
                div.className = 'rogue-card';
                div.innerHTML = `
                    <div class="card-title">${def.name} <span style="font-size:0.8em; color:#888;">Lvl ${lvl}</span></div>
                    <div class="card-desc">${def.desc}</div>
                    <div class="card-cost">${maxed ? 'MAX' : cost + ' <span class="ember-icon" style="display:inline-block;width:12px;height:12px;"></span>'}</div>
                    <button class="buy-btn" onclick="buyItem('upgrade', '${id}')" ${maxed || playerMeta.emberShards < cost ? 'disabled' : ''}>
                        ${maxed ? 'MAXED' : 'UPGRADE'}
                    </button>`;
                upContainer.appendChild(div);
            }

            // Classes
            const classContainer = document.getElementById('tab-classes');
            classContainer.innerHTML = '';
            for (const [id, def] of Object.entries(CLASSES)) {
                const unlocked = id === 'survivor' || playerMeta.unlockedClasses[id];
                const isSelected = selectedClass === id;
                const div = document.createElement('div');
                div.className = `rogue-card ${!unlocked ? 'locked' : ''}`;
                if (isSelected) div.style.borderColor = '#0f0';

                div.innerHTML = `
                    <div class="card-title">${def.name}</div>
                    <div class="card-desc">${def.desc}</div>
                    ${unlocked ?
                        `<button class="buy-btn" style="${isSelected ? 'background:#004400' : 'background:#444'}" onclick="selectClass('${id}')">${isSelected ? 'SELECTED' : 'SELECT'}</button>` :
                        `<div class="card-cost">${def.cost} <span class="ember-icon" style="display:inline-block;width:12px;height:12px;"></span></div>
                         <button class="buy-btn" onclick="buyItem('class', '${id}')" ${playerMeta.emberShards < def.cost ? 'disabled' : ''}>UNLOCK</button>`
                    }
                `;
                classContainer.appendChild(div);
            }

            // Mods
            const modContainer = document.getElementById('mods-list');
            modContainer.innerHTML = '';
            for (const [id, def] of Object.entries(MODIFIERS)) {
                const active = selectedMods.has(id);
                const div = document.createElement('div');
                div.className = `rogue-card mod-card ${active ? 'selected' : ''}`;
                div.onclick = () => toggleMod(id);
                div.innerHTML = `
                    <div class="card-title">${def.name}</div>
                    <div class="card-desc">${def.desc}</div>
                    <div class="card-stats" style="color: #0f0;">x${def.mult} Embers</div>
                `;
                modContainer.appendChild(div);
            }
        }

        function initGame() {
            const endless = document.getElementById('endless-mode-check').checked;
            const mods = Array.from(selectedMods).join(',');
            document.getElementById('meta-lobby').style.display = 'none';
            connect(selectedClass, mods, endless);
        }

        // --- CORE GAME LOBBY ---

        function connect(cls = 'survivor', mods = '', endless = false) {
            const url = `${protocol}://${window.location.host}/ws/upsidedown?userID=${encodeURIComponent(userID)}&class=${cls}&mods=${mods}&endless=${endless}`;
            socket = new WebSocket(url);

            socket.onmessage = (ev) => {
                const msg = JSON.parse(ev.data);

                if (msg.type === 'welcome') {
                    myId = msg.id;
                    if (msg.active) {
                        gameStarted = true;
                    }
                }

                if (msg.type === 'state') {
                    gameState = msg;
                    updateHUD(msg);
                }

                if (msg.type === 'game_over') {
                    showGameOver(msg);
                }
            };

            socket.onclose = () => {
                console.log("Disconnected");
                // Optional: Show disconnect screen or auto-retry (removed auto-retry to avoid loop)
            };
        }

        function restartGame() {
            document.getElementById('game-over-overlay').classList.remove('active');
            document.getElementById('meta-lobby').style.display = 'flex';
            fetchMeta();
        }

        function showGameOver(data) {
            const mins = Math.floor(data.survived / 60);
            const secs = Math.floor(data.survived % 60).toString().padStart(2, '0');
            document.getElementById('final-time').textContent = `${mins}:${secs}`;

            // Update title
            if (data.wave > 0) {
                document.getElementById('game-over-title').textContent = "WAVE " + data.wave + " SURVIVED";
            } else {
                document.getElementById('game-over-title').textContent = "CONSUMED";
            }
            document.getElementById('game-over-overlay').classList.add('active');
        }


        function updateHUD(state) {
            const me = state.players.find(p => p.id === myId);
            if (!me) return;

            // Health bar
            document.getElementById('health-fill').style.width = Math.min(100, me.health) + '%';
            document.getElementById('sanity-fill').style.width = Math.min(100, me.sanity) + '%';

            if (me.sanity < 30) {
                document.getElementById('sanity-bar').classList.add('sanity-low');
                document.body.classList.add('insane');
            } else {
                document.getElementById('sanity-bar').classList.remove('sanity-low');
                document.body.classList.remove('insane');
            }

            // Timer / Wave
            if (state.maxTime && state.maxTime < 9999) {
                const timeLeft = Math.max(0, state.maxTime - state.time);
                const mins = Math.floor(timeLeft / 60);
                const secs = Math.floor(timeLeft % 60).toString().padStart(2, '0');
                document.getElementById('timer').textContent = `${mins}:${secs}`;
            } else {
                document.getElementById('timer').textContent = `ENDLESS`; // Endless mode
            }

            // Score
            document.getElementById('score').textContent = `SCORE: ${me.score}`;

            // Flare indicator
            if (me.hasFlare) {
                document.getElementById('flare-indicator').classList.add('active');
            } else {
                document.getElementById('flare-indicator').classList.remove('active');
            }

            // Screen shake when taking damage
            if (me.health < 50) {
                document.getElementById('game-container').classList.add('screen-shake');
            } else {
                document.getElementById('game-container').classList.remove('screen-shake');
            }
        }

        // Game loop
        let lastUpdate = 0;
        function gameLoop(timestamp) {
            requestAnimationFrame(gameLoop);
            if (!gameStarted || !gameState) return;

            const dt = (timestamp - lastUpdate) / 1000;
            lastUpdate = timestamp;

            // Movement logic
            const baseSpeed = 5;
            const speed = isSprinting ? baseSpeed * 1.8 : baseSpeed;
            let dx = 0, dy = 0;
            if (keys.w) dy -= speed * dt;
            if (keys.s) dy += speed * dt;
            if (keys.a) dx -= speed * dt;
            if (keys.d) dx += speed * dt;

            if ((dx !== 0 || dy !== 0) && socket?.readyState === WebSocket.OPEN) {
                playerPos.x += dx;
                playerPos.y += dy;
                playerPos.x = Math.max(-30, Math.min(30, playerPos.x));
                playerPos.y = Math.max(-30, Math.min(30, playerPos.y));
                socket.send(JSON.stringify({ type: 'move', pos: playerPos }));
            }

            render();
        }

        function render() {
            ctx.fillStyle = '#0a0000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (!gameState) return;

            const me = gameState.players.find(p => p.id === myId);
            if (!me) return;

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const scale = 15;
            const camX = me.pos.x;
            const camY = me.pos.y;

            // Grid
            ctx.strokeStyle = 'rgba(50, 20, 20, 0.3)';
            ctx.lineWidth = 1;
            for (let x = -40; x <= 40; x += 5) {
                const screenX = centerX + (x - camX) * scale;
                ctx.beginPath(); ctx.moveTo(screenX, 0); ctx.lineTo(screenX, canvas.height); ctx.stroke();
            }
            for (let y = -40; y <= 40; y += 5) {
                const screenY = centerY + (y - camY) * scale;
                ctx.beginPath(); ctx.moveTo(0, screenY); ctx.lineTo(canvas.width, screenY); ctx.stroke();
            }

            // Entities
            for (const e of gameState.entities) {
                const sx = centerX + (e.pos.x - camX) * scale;
                const sy = centerY + (e.pos.y - camY) * scale;

                if (e.type === 'demogorgon' || e.type === 'demogorgon_boss') {
                    const isBoss = e.type === 'demogorgon_boss';
                    const headRad = isBoss ? 40 : 25;
                    const petalColor = isBoss ? '#440000' : '#8b0000';
                    const bodyColor = isBoss ? '#1a0505' : '#dcdcdc';

                    const time = Date.now() / 200;

                    // Body
                    ctx.fillStyle = bodyColor;
                    ctx.beginPath();
                    ctx.arc(sx, sy, isBoss ? 30 : 20, 0, Math.PI * 2);
                    ctx.fill();

                    // Petals
                    ctx.fillStyle = petalColor;
                    const petalCount = 5;
                    for (let i = 0; i < petalCount; i++) {
                        const angle = (i / petalCount) * Math.PI * 2 + (time * 0.1);
                        const px = sx + Math.cos(angle) * headRad;
                        const py = sy + Math.sin(angle) * headRad;
                        const midAngle = angle + (isBoss ? 0 : 0.5); // Variation

                        ctx.beginPath();
                        ctx.moveTo(sx, sy);
                        ctx.quadraticCurveTo(
                            sx + Math.cos(angle - 0.5) * (headRad + 15),
                            sy + Math.sin(angle - 0.5) * (headRad + 15),
                            px, py
                        );
                        ctx.quadraticCurveTo(
                            sx + Math.cos(angle + 0.5) * (headRad + 15),
                            sy + Math.sin(angle + 0.5) * (headRad + 15),
                            sx, sy
                        );
                        ctx.fill();
                    }

                    // Mouth
                    ctx.fillStyle = '#110';
                    ctx.beginPath();
                    ctx.arc(sx, sy, isBoss ? 20 : 12, 0, Math.PI * 2);
                    ctx.fill();

                    // Boss Health Bar
                    if (isBoss) {
                        const hpPct = (e.health || 100) / 500; // Approx max health visualization
                        // Actually backend doesn't send max health of entities in standard view.
                        // Just draw a small bar
                        ctx.fillStyle = 'red';
                        ctx.fillRect(sx - 20, sy - 50, 40 * (e.health > 0), 5);
                    }

                } else if (e.type === 'light_orb') {
                    const grad = ctx.createRadialGradient(sx, sy, 0, sx, sy, 25);
                    grad.addColorStop(0, 'rgba(255, 255, 200, 0.9)');
                    grad.addColorStop(1, 'transparent');
                    ctx.fillStyle = grad;
                    ctx.beginPath(); ctx.arc(sx, sy, 25, 0, Math.PI * 2); ctx.fill();
                } else if (e.type === 'battery') {
                    ctx.fillStyle = '#0f0'; ctx.fillRect(sx - 8, sy - 12, 16, 24);
                } else if (e.type === 'flare') {
                    ctx.fillStyle = '#f60';
                    ctx.beginPath();
                    ctx.moveTo(sx, sy - 15); ctx.lineTo(sx + 10, sy + 10); ctx.lineTo(sx - 10, sy + 10); ctx.closePath();
                    ctx.fill();
                }
            }

            // Players
            for (const p of gameState.players) {
                if (p.id === myId || !p.alive) continue;
                const sx = centerX + (p.pos.x - camX) * scale;
                const sy = centerY + (p.pos.y - camY) * scale;

                const lightGrad = ctx.createRadialGradient(sx, sy, 0, sx, sy, p.lightRadius * scale);
                lightGrad.addColorStop(0, 'rgba(255, 200, 150, 0.3)');
                lightGrad.addColorStop(1, 'transparent');
                ctx.fillStyle = lightGrad;
                ctx.beginPath(); ctx.arc(sx, sy, p.lightRadius * scale, 0, Math.PI * 2); ctx.fill();

                ctx.fillStyle = '#aaa';
                ctx.beginPath(); ctx.arc(sx, sy, 12, 0, Math.PI * 2); ctx.fill();

                ctx.fillStyle = '#fff';
                ctx.font = '12px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(p.name, sx, sy - 20);
            }

            // Self
            if (me.alive) {
                const lightGrad = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, me.lightRadius * scale);
                lightGrad.addColorStop(0, 'rgba(255, 200, 150, 0.4)');
                lightGrad.addColorStop(1, 'transparent');
                ctx.fillStyle = lightGrad;
                ctx.beginPath(); ctx.arc(centerX, centerY, me.lightRadius * scale, 0, Math.PI * 2); ctx.fill();

                ctx.fillStyle = me.hasFlare ? '#ff8800' : '#fff';
                ctx.beginPath(); ctx.arc(centerX, centerY, 15, 0, Math.PI * 2); ctx.fill();
            }

            // Darkness
            const darknessRadius = (me.sanity / 100) * 300 + 100;
            const darkGrad = ctx.createRadialGradient(centerX, centerY, darknessRadius * 0.5, centerX, centerY, darknessRadius);
            darkGrad.addColorStop(0, 'transparent');
            darkGrad.addColorStop(1, 'rgba(0, 0, 0, 0.9)');
            ctx.fillStyle = darkGrad;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // Initialize
        fetchMeta();
        requestAnimationFrame(gameLoop);

    </script>
</body>

</html>